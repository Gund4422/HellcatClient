package me.ht9.rose.feature.module.modules.exploit.boatfly;

import me.ht9.rose.event.bus.annotation.SubscribeEvent;
import me.ht9.rose.event.events.PosRotUpdateEvent;
import me.ht9.rose.feature.module.Module;
import me.ht9.rose.feature.module.annotation.Description;
import me.ht9.rose.feature.module.setting.Setting;
import me.ht9.rose.mixin.accessors.NetClientHandlerAccessor;
import me.ht9.rose.mixinterface.INetworkManager;
import org.lwjgl.input.Keyboard;
import net.minecraft.src.*;

@Description("Ascend to the heavens in a wooden tub. Defy god and physics and also other stuff.")
public final class BoatFly extends Module {
    private static final BoatFly instance = new BoatFly();

    public final Setting<Double> speed = new Setting<>("Speed", 1.0, 5.0, 20.0);
    public final Setting<Double> verticalSpeed = new Setting<>("Vertical", 1.0, 2.0, 10.0);
    public final Setting<Boolean> antiFall = new Setting<>("Hover", true);
    public final Setting<Integer> packetMult = new Setting<>("Burst", 1, 1, 10);

    @SubscribeEvent
    public void onUpdate(PosRotUpdateEvent event) {
        if (mc.thePlayer.ridingEntity == null || !(mc.thePlayer.ridingEntity instanceof EntityBoat boat)) return;

        double xVel = 0, yVel = 0, zVel = 0;

        // HELL FORK: Directional Math for 3D Movement
        float yaw = mc.thePlayer.rotationYaw;
        float forward = mc.thePlayer.movementInput.moveForward;
        float strafe = mc.thePlayer.movementInput.moveStrafe;

        if (Keyboard.isKeyDown(mc.gameSettings.keyBindJump.keyCode)) {
            yVel = verticalSpeed.value();
        } else if (Keyboard.isKeyDown(mc.gameSettings.keyBindSneak.keyCode)) {
            yVel = -verticalSpeed.value();
        } else if (antiFall.value()) {
            yVel = 0.001; 
        }

        if (forward != 0 || strafe != 0) {
            double mx = -Math.sin(Math.toRadians(yaw));
            double mz = Math.cos(Math.toRadians(yaw));
            xVel = (forward * mx + strafe * mz) * speed.value();
            zVel = (forward * mz - strafe * mx) * speed.value();
        }

        boat.motionX = xVel;
        boat.motionY = yVel;
        boat.motionZ = zVel;

        for (int i = 0; i < packetMult.value(); i++) {
            mc.getSendQueue().addToSendQueue(new Packet19EntityAction(mc.thePlayer, 1)); // Crouch to dismount-sync
            ((INetworkManager)((NetClientHandlerAccessor) mc.getSendQueue()).netManager()).rose_babric$sendWithoutEvent(
                new Packet13PlayerLookMove(boat.posX + boat.motionX, boat.posY + boat.motionY, boat.posY + boat.motionY + 0.6, boat.posZ + boat.motionZ, yaw, 0, false)
            );
        }
    }

    public static BoatFly instance() { return instance; }
}
