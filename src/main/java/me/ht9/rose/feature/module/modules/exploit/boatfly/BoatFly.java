package me.ht9.rose.feature.module.modules.exploit.boatfly;

import me.ht9.rose.event.bus.annotation.SubscribeEvent;
import me.ht9.rose.event.events.PosRotUpdateEvent;
import me.ht9.rose.feature.module.Module;
import me.ht9.rose.feature.module.annotation.Description;
import me.ht9.rose.feature.module.setting.Setting;
import me.ht9.rose.mixin.accessors.EntityAccessor; // You'll need an accessor for 'inWater'
import net.minecraft.src.*;
import org.lwjgl.input.Keyboard;

@Description("Forces the boat to think the air is water for infinite buoyancy.")
public final class BoatFly extends Module {
    private static final BoatFly instance = new BoatFly();

    public final Setting<Double> speed = new Setting<>("Speed", 0.5, 3.0, 10.0);
    public final Setting<Double> verticalSpeed = new Setting<>("Vertical", 0.5, 2.0, 5.0);
    public final Setting<Boolean> oceanAir = new Setting<>("Oceanic Air", true);

    private BoatFly() {}

    @SubscribeEvent
    public void onUpdate(PosRotUpdateEvent event) {
        if (mc.thePlayer.ridingEntity == null || !(mc.thePlayer.ridingEntity instanceof EntityBoat boat)) return;

        // 1. THE "GASLIGHT" OVERRIDE
        if (oceanAir.value()) {
            // Force the boat to think it's submerged. 
            // This prevents the 'falling' animation and resets the fall distance.
            ((EntityAccessor) boat).setInWater(true);
            boat.fallDistance = 0.0f;
            boat.isAirBorne = false;
        }

        // 2. Kill vanilla gravity so the 'water' doesn't make us sink/bob
        boat.motionX = 0;
        boat.motionY = 0;
        boat.motionZ = 0;

        // 3. Directional Math
        double[] dir = getDirectionSpeed(speed.value());
        
        // 4. Input Handling
        double moveX = dir[0];
        double moveZ = dir[1];
        double moveY = 0;

        if (Keyboard.isKeyDown(mc.gameSettings.keyBindJump.keyCode)) {
            moveY = verticalSpeed.value() / 5;
        } else if (Keyboard.isKeyDown(mc.gameSettings.keyBindSneak.keyCode)) {
            moveY = -verticalSpeed.value() / 5;
        }

        // 5. Apply Movement
        // We use moveEntity to let the boat handle collisions, 
        // making the flight feel 'solid' against walls.
        boat.moveEntity(moveX, moveY, moveZ);

        // 6. Packet Sync (Ensures the server sees the boat 'floating' in air)
        mc.getSendQueue().addToSendQueue(new Packet10Flying(true));
    }

    private double[] getDirectionSpeed(double speed) {
        float forward = mc.thePlayer.movementInput.moveForward;
        float side = mc.thePlayer.movementInput.moveStrafe;
        float yaw = mc.thePlayer.rotationYaw;
        if (forward == 0 && side == 0) return new double[]{0, 0};

        double sin = Math.sin(Math.toRadians(yaw));
        double cos = Math.cos(Math.toRadians(yaw));

        return new double[]{
            (forward * -sin + side * cos) * speed / 5,
            (forward * cos + side * sin) * speed / 5
        };
    }

    public static BoatFly instance() { return instance; }
}
