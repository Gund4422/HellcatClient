package me.ht9.rose.feature.module.modules.exploit.boatfly;

import me.ht9.rose.event.bus.annotation.SubscribeEvent;
import me.ht9.rose.event.events.PosRotUpdateEvent;
import me.ht9.rose.feature.module.Module;
import me.ht9.rose.feature.module.annotation.Description;
import me.ht9.rose.feature.module.setting.Setting;
import net.minecraft.src.*;
import org.lwjgl.input.Keyboard;
import java.lang.reflect.Field;

@Description("Forces the boat to think the air is water for infinite buoyancy.")
public final class BoatFly extends Module {
    private static final BoatFly instance = new BoatFly();
    
    // We store the fields here to avoid searching for them every single tick
    private Field inWaterField = null;
    private Field fallDistanceField = null;
    private Field isAirBorneField = null;

    public final Setting<Double> speed = new Setting<>("Speed", 0.5, 3.0, 10.0);
    public final Setting<Double> verticalSpeed = new Setting<>("Vertical", 0.5, 2.0, 5.0);

    private BoatFly() {
        try {
            inWaterField = Entity.class.getDeclaredField("inWater");
            inWaterField.setAccessible(true);
            
            fallDistanceField = Entity.class.getDeclaredField("fallDistance");
            fallDistanceField.setAccessible(true);
            
            try {
                isAirBorneField = Entity.class.getDeclaredField("isAirBorne");
                isAirBorneField.setAccessible(true);
            } catch (Exception ignored) {}

        } catch (Exception e) {
            System.out.println("Hose: One or more fields not found via reflection.");
        }
    }

    @SubscribeEvent
    public void onUpdate(PosRotUpdateEvent event) {
        if (mc.thePlayer.ridingEntity == null || !(mc.thePlayer.ridingEntity instanceof EntityBoat boat)) return;

        // 1. GASLIGHTING THE PHYSICS VIA REFLECTION
        try {
            if (inWaterField != null) inWaterField.setBoolean(boat, true);
            if (fallDistanceField != null) fallDistanceField.setFloat(boat, 0.0f);
            if (isAirBorneField != null) isAirBorneField.setBoolean(boat, false);
        } catch (Exception ignored) {}

        // 2. MOVEMENT LOGIC
        boat.motionX = 0;
        boat.motionY = 0;
        boat.motionZ = 0;

        double[] dir = getDirectionSpeed(speed.value());
        double moveY = 0;

        if (Keyboard.isKeyDown(mc.gameSettings.keyBindJump.keyCode)) {
            moveY = verticalSpeed.value() / 5;
        } else if (Keyboard.isKeyDown(mc.gameSettings.keyBindSneak.keyCode)) {
            moveY = -verticalSpeed.value() / 5;
        }

        // Apply movement
        boat.moveEntity(dir[0], moveY, dir[1]);

        // 3. SERVER SYNC
        mc.getSendQueue().addToSendQueue(new Packet10Flying(true));
    }

    private double[] getDirectionSpeed(double speed) {
        float yaw = mc.thePlayer.rotationYaw;
        float forward = mc.thePlayer.movementInput.moveForward;
        float side = mc.thePlayer.movementInput.moveStrafe;
        
        if (forward == 0 && side == 0) return new double[]{0, 0};

        double sin = Math.sin(Math.toRadians(yaw));
        double cos = Math.cos(Math.toRadians(yaw));

        return new double[]{
            (forward * -sin + side * cos) * speed / 5,
            (forward * cos + side * sin) * speed / 5
        };
    }

    public static BoatFly instance() { 
        return instance; 
    }
}
