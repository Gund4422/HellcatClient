package me.ht9.rose.feature.module.modules.exploit.boatfly;

import me.ht9.rose.event.bus.annotation.SubscribeEvent;
import me.ht9.rose.event.events.PosRotUpdateEvent;
import me.ht9.rose.feature.module.Module;
import me.ht9.rose.feature.module.annotation.Description;
import me.ht9.rose.feature.module.setting.Setting;
import net.minecraft.src.*;
import org.lwjgl.input.Keyboard;
import java.lang.reflect.Field;

@Description("Teleport-based flight for Beta 1.7.3. Moves like a jet, hits like a nuke.")
public final class BoatFly extends Module {
    private static final BoatFly instance = new BoatFly();
    
    private Field inWaterField = null;
    private Field fallDistanceField = null;
    private Field isAirBorneField = null;

    public final Setting<Double> speed = new Setting<>("Speed", 0.5, 14.0, 30.0);
    public final Setting<Double> verticalTP = new Setting<>("Vertical TP", 0.5, 1.0, 5.0);

    private BoatFly() {
        try {
            inWaterField = Entity.class.getDeclaredField("inWater");
            inWaterField.setAccessible(true);
            
            fallDistanceField = Entity.class.getDeclaredField("fallDistance");
            fallDistanceField.setAccessible(true);
            
            try {
                isAirBorneField = Entity.class.getDeclaredField("isAirBorne");
                isAirBorneField.setAccessible(true);
            } catch (Exception ignored) {}

        } catch (Exception e) {
            System.out.println("Hose: Reflection failed. Anti-break might not work.");
        }
    }

    @SubscribeEvent
    public void onUpdate(PosRotUpdateEvent event) {
        if (mc.thePlayer.ridingEntity == null || !(mc.thePlayer.ridingEntity instanceof EntityBoat boat)) return;

        try {
            if (inWaterField != null) inWaterField.setBoolean(boat, true);
            if (fallDistanceField != null) fallDistanceField.setFloat(boat, 0.0f);
            if (isAirBorneField != null) isAirBorneField.setBoolean(boat, false);
        } catch (Exception ignored) {}

        boat.motionX = 0;
        boat.motionY = 0;
        boat.motionZ = 0;

        double tpspeed = speed.value() / 20.0;
        double[] dir = getDirectionSpeed(tpspeed);

        double newX = boat.posX + dir[0];
        double newY = boat.posY;
        double newZ = boat.posZ + dir[1];

        if (Keyboard.isKeyDown(mc.gameSettings.keyBindJump.keyCode)) {
            newY += verticalTP.value(); // Instant 1-block leap
        } else if (Keyboard.isKeyDown(mc.gameSettings.keyBindSneak.keyCode)) {
            newY -= verticalTP.value(); // Instant 1-block drop
        }

        boat.setPosition(newX, newY, newZ);

        mc.getSendQueue().addToSendQueue(new Packet10Flying(true));
    }

    private double[] getDirectionSpeed(double speed) {
        float yaw = mc.thePlayer.rotationYaw;
        float forward = mc.thePlayer.movementInput.moveForward;
        float side = mc.thePlayer.movementInput.moveStrafe;
        
        if (forward == 0 && side == 0) return new double[]{0, 0};

        double sin = Math.sin(Math.toRadians(yaw));
        double cos = Math.cos(Math.toRadians(yaw));

        return new double[]{
            (forward * -sin + side * cos) * speed,
            (forward * cos + side * sin) * speed
        };
    }

    public static BoatFly instance() { 
        return instance; 
    }
}
