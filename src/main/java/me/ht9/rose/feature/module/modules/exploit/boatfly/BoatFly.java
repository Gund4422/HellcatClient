package me.ht9.rose.feature.module.modules.exploit.boatfly;

import me.ht9.rose.event.bus.annotation.SubscribeEvent;
import me.ht9.rose.event.events.PosRotUpdateEvent;
import me.ht9.rose.feature.module.Module;
import me.ht9.rose.feature.module.annotation.Description;
import me.ht9.rose.feature.module.setting.Setting;
import me.ht9.rose.mixin.accessors.NetClientHandlerAccessor;
import me.ht9.rose.mixinterface.INetworkManager;
import net.minecraft.src.*;
import org.lwjgl.input.Keyboard;

@Description("Modern Packet-based BoatFly. The first of its kind for Beta 1.7.3.")
public final class BoatFly extends Module {
    private static final BoatFly instance = new BoatFly();

    public final Setting<Double> speed = new Setting<>("Speed", 0.5, 3.0, 10.0);
    public final Setting<Double> verticalSpeed = new Setting<>("Vertical", 0.5, 2.0, 5.0);
    public final Setting<Integer> packetMult = new Setting<>("Hose Pressure", 1, 2, 5);
    public final Setting<Boolean> antiFall = new Setting<>("AntiFall", true);

    private BoatFly() {
        setArrayListInfo(() -> String.format("%.1f", speed.value()));
    }

    @SubscribeEvent
    public void onUpdate(PosRotUpdateEvent event) {
        // Only run if we are actually hosing around in a boat
        if (mc.thePlayer.ridingEntity == null || !(mc.thePlayer.ridingEntity instanceof EntityBoat boat)) return;

        // 1. Kill vanilla physics to stop rubberbanding
        boat.motionX = 0;
        boat.motionY = 0;
        boat.motionZ = 0;

        // 2. Calculate Movement Vectors
        double[] dir = getDirectionSpeed(speed.value());
        double x = boat.posX + dir[0];
        double y = boat.posY;
        double z = boat.posZ + dir[1];

        // 3. Handle Vertical Movement (Jump/Sneak)
        if (Keyboard.isKeyDown(mc.gameSettings.keyBindJump.keyCode)) {
            y += verticalSpeed.value() / 2;
        } else if (Keyboard.isKeyDown(mc.gameSettings.keyBindSneak.keyCode)) {
            y -= verticalSpeed.value() / 2;
        } else if (antiFall.value()) {
            y += 0.001; // Tiny lift to negate gravity packets
        }

        // 4. Update Client-Side Entity Position
        boat.setPosition(x, y, z);

        // 5. THE PACKET HOSE (Packet Sync)
        for (int i = 0; i < packetMult.value(); i++) {
            // Send Player Position (Server thinks we are sitting still in the boat)
            mc.getSendQueue().addToSendQueue(new Packet10Flying(true));

            // Force Server to sync Boat Position
            // We use the Rose/Hose mixin to send directly without triggering other events
            ((INetworkManager)((NetClientHandlerAccessor) mc.getSendQueue()).netManager())
                .rose_babric$sendWithoutEvent(new Packet13PlayerLookMove(
                    boat.posX, boat.posY, boat.posY + 0.6, boat.posZ, 
                    mc.thePlayer.rotationYaw, mc.thePlayer.rotationPitch, true
                ));
        }
    }

    // Helper Math to convert player view into X/Z movement
    private double[] getDirectionSpeed(double speed) {
        float forward = mc.thePlayer.movementInput.moveForward;
        float side = mc.thePlayer.movementInput.moveStrafe;
        float yaw = mc.thePlayer.rotationYaw;

        if (forward == 0 && side == 0) return new double[]{0, 0};

        // Convert movement to radians and calculate sin/cos
        double sin = Math.sin(Math.toRadians(yaw));
        double cos = Math.cos(Math.toRadians(yaw));

        double dx = (forward * -sin + side * cos) * speed / 5;
        double dz = (forward * cos + side * sin) * speed / 5;

        return new double[]{dx, dz};
    }

    public static BoatFly instance() {
        return instance;
    }
}
