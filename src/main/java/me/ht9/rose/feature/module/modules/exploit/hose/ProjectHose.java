package me.ht9.rose.feature.module.modules.exploit.hose;

import me.ht9.rose.event.bus.annotation.SubscribeEvent;
import me.ht9.rose.event.events.PosRotUpdateEvent;
import me.ht9.rose.feature.module.Module;
import me.ht9.rose.feature.module.annotation.Description;
import me.ht9.rose.feature.module.setting.Setting;
import net.minecraft.src.Block;
import org.lwjgl.input.Keyboard;

import java.util.concurrent.atomic.AtomicBoolean;

@Description("Cracks the world seed from the bedrock floor (CPU Brute-force)")
public final class ProjectHose extends Module {
    private static final ProjectHose instance = new ProjectHose();
    
    // Settings for the Hellcat GUI
    private final Setting<Boolean> logProgress = new Setting<>("LogProgress", true);
    private final Setting<Integer> threadCount = new Setting<>("Threads", 4, 1, 16, 0);

    private final AtomicBoolean isCracking = new AtomicBoolean(false);
    private long foundSeed = -1;

    private ProjectHose() {
        setArrayListInfo(() -> isCracking.get() ? "§6Hosing..." : (foundSeed != -1 ? "§a" + foundSeed : "Ready"));
    }

    @SubscribeEvent
    public void onUpdate(PosRotUpdateEvent event) {
        if (mc.thePlayer == null || mc.theWorld == null || isCracking.get()) return;

        // Auto-trigger: When you enable the module, it grabs the chunk you're in
        int cx = (int) mc.thePlayer.posX >> 4;
        int cz = (int) mc.thePlayer.posZ >> 4;

        int[] bedrockPattern = new int[256];
        for (int x = 0; x < 16; x++) {
            for (int z = 0; z < 16; z++) {
                for (int y = 4; y >= 0; y--) {
                    if (mc.theWorld.getBlockId((cx << 4) + x, y, (cz << 4) + z) == Block.bedrock.blockID) {
                        bedrockPattern[x * 16 + z] = y;
                        break;
                    }
                }
            }
        }

        // START BRUTE FORCE THREAD
        isCracking.set(true);
        new Thread(() -> {
            mc.thePlayer.addChatMessage("§c[Hellcat] §7Siphoning bedrock data... Starting threads.");
            
            long result = runHose(bedrockPattern);
            
            if (result != -1) {
                this.foundSeed = result;
                mc.thePlayer.addChatMessage("§c[Hellcat] §fSEED FOUND: §a" + result);
                mc.thePlayer.addChatMessage("§7(Check your log for the full 64-bit seed)");
            } else {
                mc.thePlayer.addChatMessage("§c[Hellcat] §7No seed found in this chunk.");
            }
            isCracking.set(false);
        }, "Hellcat-Hose-Thread").start();
    }

    // --- THE MATH ENGINE (Direct LCG) ---
    private long runHose(int[] pattern) {
        final long MULTIPLIER = 0x5DEECE66DL;
        final long ADDEND = 0xBL;
        final long MASK = (1L << 48) - 1;
        
        int threads = threadCount.value();
        long range = (1L << 48) / threads;
        AtomicBoolean stop = new AtomicBoolean(false);
        AtomicLong winner = new AtomicLong(-1);

        Thread[] workers = new Thread[threads];
        for (int t = 0; t < threads; t++) {
            final long start = t * range;
            final long end = (t == threads - 1) ? (1L << 48) : (t + 1) * range;

            workers[t] = new Thread(() -> {
                for (long s = start; s < end; s++) {
                    if (stop.get()) return;

                    long current = s;
                    boolean match = true;
                    // Check bedrock loop
                    for (int i = 0; i < 256; i++) {
                        current = (current * MULTIPLIER + ADDEND) & MASK;
                        int nextInt5 = (int) (current >>> 17) % 5;
                        if (nextInt5 < pattern[i]) {
                            match = false;
                            break;
                        }
                    }

                    if (match) {
                        winner.set(s ^ MULTIPLIER); // Resulting World Seed
                        stop.set(true);
                        return;
                    }
                }
            });
            workers[t].start();
        }

        // Wait for workers to finish
        try {
            for (Thread w : workers) w.join();
        } catch (InterruptedException e) { e.printStackTrace(); }

        return winner.get();
    }

    public static ProjectHose instance() { return instance; }
}
